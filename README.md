# Async C# interop with Rust

This project demos two approaches to create async Rust FFI bindings and C# / .NET scaffoldings.

## Using UniFFI

1. Install [`uniffi-bindgen-cs`](https://github.com/NordSecurity/uniffi-bindgen-cs) with:

   ```bash
   cargo install uniffi-bindgen-cs --git https://github.com/NordSecurity/uniffi-bindgen-cs --tag v0.9.1+v0.28.3
   ```
   Note down the second version number (in the example above, `0.28.3`). This is the upstream [`uniffi`](https://github.com/mozilla/uniffi-rs)
   version used for generating FFI scaffolding in Rust binary that the generated C# bindings will be compatible with. Update `Cargo.toml` accordingly.

2. Build the Rust library with:

   ```bash
   cargo build --release
   ```

   There's no need to write the Rust scaffolding manually, it's auto-generated by UniFFI during build based on info read from [Procedural Macros](https://mozilla.github.io/uniffi-rs/0.29/proc_macro/index.html).

   Compared with popular C# binding generator crates such as [`csbindgen`](https://github.com/Cysharp/csbindgen) that only generate target language bindings based on handwritten Rust FFI scaffolding, `UniFFI` covers both bindings and scaffolding, so it's much easier for quickly setting up interop, especially for handling async code.

   The downsides are:

   1. Interop performance is highly dependent on `UniFFI` implementation (and the corresponding 3rd party binding generator for C#).

   2. There's no control over binding and scaffolding implementations. Whether certain (latest) Rust features can be supported is highly depedent on what `UniFFI` supports (or the version of `UniFFI` that the 3rd party binding generator supports).

   To see the generated [FFI scaffolding code](https://mozilla.github.io/uniffi-rs/0.29/glossary.html#scaffolding), install [`cargo-expand`](https://github.com/dtolnay/cargo-expand) then run `cargo expand --lib`.

3. Generate the C# binding code with:

   ```bash
   uniffi-bindgen-cs.exe --library target\release\async_ffi.dll --out-dir="binding\csharp"
   ```

   Change the path to the library to `target/release/libasync_ffi.so` for Linux, or `target/release/libasync_ffi.dylib` for MacOS.

   Alternatively, to generate bindings for Python, use the official `uniffi-bindgen` tool instead, which is in sync with the latest `UniFFI` version:

   ```bash
   cargo run --bin uniffi_bindgen generate --library target\release\async_ffi.dll --language python --out-dir binding\python
   ```

4. Copy `async_ffi.cs` from `binding\csharp` to the root directory of the C# project `dotnet`. Rename the file to `RustInteropUniFFI.cs`.

5. Go to directory `dotnet` and run the C# project with `dotnet run`.

   The `async_ffi.dll` / `async_ffi.so` library file should be automatically copied to the output directory as part of the build process
   configured in `dotnet.csproj`.


## Writing interop manually with mpsc

The Rustonomicon has the following recommendation about writing [async callbacks](https://doc.rust-lang.org/nomicon/ffi.html#asynchronous-callbacks):

> Things get more complicated when the external library spawns its own threads and invokes callbacks from there.
> In these cases access to Rust data structures inside the callbacks is especially unsafe and proper synchronization mechanisms
> must be used. Besides classical synchronization mechanisms like mutexes, one possibility in Rust is to **use channels
> (in `std::sync::mpsc`) to forward data from the C thread that invoked the callback into a Rust thread**.

This project implements a manual async FFI approach using `tokio::sync::mpsc` channels that follows this recommendation.

### Implementation Overview

The manual implementation consists of:

1. **Rust FFI functions** (`src/lib.rs`):
   - `init_async_runtime()` - Initializes a global Tokio runtime
   - `say_hello_async_manual()` - Accepts a C string, callback function, and user data
   - `cleanup_async_runtime()` - Cleanup function (no-op with current implementation)
   - Uses `tokio::sync::mpsc` channels to communicate between async tasks
   - Follows the callback pattern recommended by the Rustonomicon

2. **C# P/Invoke bindings** (`dotnet/RustInteropManual.cs`):
   - Declares extern functions to call Rust FFI functions
   - Implements `SayHelloAsync()` method that returns a `Task<string>`
   - Uses `TaskCompletionSource` to bridge the callback pattern to C# async/await
   - Properly manages memory and GC handles

### Key Differences from UniFFI Approach

| Aspect | UniFFI | Manual mpsc |
|--------|--------|-------------|
| **Code Generation** | Auto-generated scaffolding and bindings | Hand-written FFI and P/Invoke |
| **Async Implementation** | UniFFI's built-in async runtime integration | Custom callback-based approach with channels |
| **Memory Management** | Handled by UniFFI | Manual string allocation/deallocation |
| **Threading** | Abstract, handled by UniFFI | Explicit use of Tokio tasks and threads |
| **Channel Usage** | Internal to UniFFI | Explicit `tokio::sync::mpsc` channel usage |
| **Performance** | Optimized by UniFFI | Direct FFI calls, potentially lower overhead |
| **Flexibility** | Limited to UniFFI capabilities | Full control over implementation |

### Running the Example

1. Build the Rust library:
   ```bash
   cargo build --release
   ```

2. Run the C# project:
   ```bash
   cd dotnet
   dotnet run
   ```

The program will demonstrate both approaches:
- **Test #1**: UniFFI-based async interop
- **Test #2**: Manual mpsc-based async interop with concurrent calls

You'll notice different thread IDs in the output, showing that the manual approach uses actual Tokio thread pool threads, while the mpsc channels facilitate safe communication between the FFI boundary and the async tasks.
