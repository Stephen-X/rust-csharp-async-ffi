# Async C# interop with Rust

This project demos two approaches to create async Rust FFI bindings and C# / .NET scaffoldings.

## Using UniFFI

1. Install [`uniffi-bindgen-cs`](https://github.com/NordSecurity/uniffi-bindgen-cs) with:

   ```bash
   cargo install uniffi-bindgen-cs --git https://github.com/NordSecurity/uniffi-bindgen-cs --tag v0.10.0+v0.29.4
   ```
   Note down the second version number (in the example above, `0.29.4`). This is the upstream [`uniffi`](https://github.com/mozilla/uniffi-rs)
   version used for generating FFI scaffolding in Rust binary that the generated C# bindings will be compatible with. Update `Cargo.toml` accordingly.

2. Build the Rust library with:

   ```bash
   cargo build --release
   ```

   There's no need to write the Rust scaffolding manually, it's auto-generated by UniFFI during build based on info read from [Procedural Macros](https://mozilla.github.io/uniffi-rs/0.29/proc_macro/index.html).

   Compared with popular C# binding generator crates such as [`csbindgen`](https://github.com/Cysharp/csbindgen) that only generate target language bindings based on handwritten Rust FFI scaffolding, `UniFFI` covers both bindings and scaffolding, so it's much easier for quickly setting up interop, especially for handling async code.

   The downsides are:

   1. Interop performance is highly dependent on `UniFFI` implementation (and the corresponding 3rd party binding generator for C#).

   2. There's no control over binding and scaffolding implementations. Whether certain (latest) Rust features can be supported is highly depedent on what `UniFFI` supports (or the version of `UniFFI` that the 3rd party binding generator supports).

   To see the generated [FFI scaffolding code](https://mozilla.github.io/uniffi-rs/0.29/glossary.html#scaffolding), install [`cargo-expand`](https://github.com/dtolnay/cargo-expand) then run `cargo expand --lib`.

3. Generate the C# binding code with:

   ```bash
   uniffi-bindgen-cs.exe --library target\release\async_ffi.dll --out-dir="binding\csharp" --no-format

   # CSharpier auto-formatting is currently not supported due to breaking changes made to version 1.0.
   # Install and run tool manually instead: https://github.com/NordSecurity/uniffi-bindgen-cs/issues/116
   csharpier format binding\csharp\async_ffi.cs --include-generated
   ```

   Remove the `.exe` extension and change the path to the library to `target/release/libasync_ffi.so` for Linux, or `target/release/libasync_ffi.dylib` for MacOS.

   Alternatively, to generate bindings for Python, use the official `uniffi-bindgen` tool instead, which is in sync with the latest `UniFFI` version:

   ```bash
   cargo run --bin uniffi_bindgen generate --library target\release\async_ffi.dll --language python --out-dir binding\python
   ```

4. Copy `async_ffi.cs` from `binding\csharp` to the root directory of the C# project `dotnet`. Rename the file to `RustInteropUniFFI.cs`.

5. Go to directory `dotnet` and run the C# project with `dotnet run`.

   The `async_ffi.dll` / `libasync_ffi.so` / `libasync_ffi.dylib` library file should be automatically copied to the output directory as part of the build process
   configured in `dotnet.csproj`.

   Example output:

   ```bash
   [02:42:09.395] INF TID:2 ######## Test #1: Interop with UniFFI ########
   [02:42:09.408] INF TID:2 #1.1. Call SayHelloAsync in parallel:
   [02:42:09.442] INF TID:7 ##Run 3## [thread=ThreadId(3)][task=Id(1)][sample=132532][pi=3.151540759967404] Hello, JohnðŸ‘“!
   [02:42:09.442] INF TID:8 ##Run 1## [thread=ThreadId(3)][task=Id(3)][sample=627856][pi=3.1448166458551006] Hello, StÃ©phanos!
   [02:42:09.447] INF TID:8 ##Run 2## [thread=ThreadId(3)][task=Id(2)][sample=493654][pi=3.141998241683446] Hello, è³“!
   [02:42:09.447] INF TID:8 #Parallel calls completed in 39 ms
   [02:42:09.447] INF TID:8 #1.2. Call SayHelloAsync sequentially:
   [02:42:09.454] INF TID:8 ##Run 1## [thread=ThreadId(3)][task=Id(4)][sample=627856][pi=3.1403124283275146] Hello, StÃ©phanos!
   [02:42:09.463] INF TID:8 ##Run 2## [thread=ThreadId(3)][task=Id(5)][sample=493654][pi=3.139915811479295] Hello, è³“!
   [02:42:09.465] INF TID:8 ##Run 3## [thread=ThreadId(3)][task=Id(6)][sample=132532][pi=3.142637249871729] Hello, JohnðŸ‘“!
   [02:42:09.465] INF TID:8 #Sequential calls completed in 17 ms
   ```


## Writing interop manually with Tokio

`src/ffi.rs` and `dotnet/RustInteropTokio.cs` demo how to write async Rust FFI bindings and C# scaffoldings manually with `tokio` runtime.

1. Build the Rust library with:

   ```bash
   cargo build --release
   ```

2. Go to directory `dotnet` and run the C# project with `dotnet run`.

   Example output:

   ```bash
   [02:42:09.465] INF TID:8 ######## Test #2: Interop with async FFI ########
   [02:42:09.465] INF TID:8 #2.1. Call SayHelloAsync in parallel:
   [02:42:09.470] INF TID:10 ##Run 3## [thread=ThreadId(19)][task=Id(27)][sample=132532][pi=3.147104095614644] Hello, JohnðŸ‘“!
   [02:42:09.475] INF TID:11 ##Run 2## [thread=ThreadId(20)][task=Id(26)][sample=493654][pi=3.1417389507630853] Hello, è³“!
   [02:42:09.476] INF TID:12 ##Run 1## [thread=ThreadId(18)][task=Id(28)][sample=627856][pi=3.1406182309319335] Hello, StÃ©phanos!
   [02:42:09.477] INF TID:7 #Parallel calls completed in 11 ms
   [02:42:09.477] INF TID:7 #2.2. Call SayHelloAsync sequentially:
   [02:42:09.485] INF TID:12 ##Run 1## [thread=ThreadId(18)][task=Id(30)][sample=627856][pi=3.1421090186284752] Hello, StÃ©phanos!
   [02:42:09.493] INF TID:12 ##Run 2## [thread=ThreadId(18)][task=Id(32)][sample=493654][pi=3.140588347303982] Hello, è³“!
   [02:42:09.495] INF TID:12 ##Run 3## [thread=ThreadId(18)][task=Id(34)][sample=132532][pi=3.1327679352910995] Hello, JohnðŸ‘“!
   [02:42:09.495] INF TID:12 #Sequential calls completed in 18 ms
   ```
