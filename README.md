# Async C# interop with Rust

This project demos two approaches to create async Rust FFI bindings and C# / .NET scaffoldings.

## Using UniFFI

1. Install [`uniffi-bindgen-cs`](https://github.com/NordSecurity/uniffi-bindgen-cs) with:

   ```bash
   cargo install uniffi-bindgen-cs --git https://github.com/NordSecurity/uniffi-bindgen-cs --tag v0.10.0+v0.29.4
   ```
   Note down the second version number (in the example above, `0.29.4`). This is the upstream [`uniffi`](https://github.com/mozilla/uniffi-rs)
   version used for generating FFI scaffolding in Rust binary that the generated C# bindings will be compatible with. Update `Cargo.toml` accordingly.

2. Build the Rust library with:

   ```bash
   cargo build --release
   ```

   There's no need to write the Rust scaffolding manually, it's auto-generated by UniFFI during build based on info read from [Procedural Macros](https://mozilla.github.io/uniffi-rs/0.29/proc_macro/index.html).

   Compared with popular C# binding generator crates such as [`csbindgen`](https://github.com/Cysharp/csbindgen) that only generate target language bindings based on handwritten Rust FFI scaffolding, `UniFFI` covers both bindings and scaffolding, so it's much easier for quickly setting up interop, especially for handling async code.

   The downsides are:

   1. Interop performance is highly dependent on `UniFFI` implementation (and the corresponding 3rd party binding generator for C#).

   2. There's no control over binding and scaffolding implementations. Whether certain (latest) Rust features can be supported is highly depedent on what `UniFFI` supports (or the version of `UniFFI` that the 3rd party binding generator supports).

   To see the generated [FFI scaffolding code](https://mozilla.github.io/uniffi-rs/0.29/glossary.html#scaffolding), install [`cargo-expand`](https://github.com/dtolnay/cargo-expand) then run `cargo expand --lib`.

3. Generate the C# binding code with:

   ```bash
   uniffi-bindgen-cs.exe --library target\release\async_ffi.dll --out-dir="binding\csharp"
   ```

   Remove the `.exe` extension and change the path to the library to `target/release/libasync_ffi.so` for Linux, or `target/release/libasync_ffi.dylib` for MacOS.

   Alternatively, to generate bindings for Python, use the official `uniffi-bindgen` tool instead, which is in sync with the latest `UniFFI` version:

   ```bash
   cargo run --bin uniffi_bindgen generate --library target\release\async_ffi.dll --language python --out-dir binding\python
   ```

4. Copy `async_ffi.cs` from `binding\csharp` to the root directory of the C# project `dotnet`. Rename the file to `RustInteropUniFFI.cs`.

5. Go to directory `dotnet` and run the C# project with `dotnet run`.

   The `async_ffi.dll` / `libasync_ffi.so` / `libasync_ffi.dylib` library file should be automatically copied to the output directory as part of the build process
   configured in `dotnet.csproj`.

   Example output:

   ```bash
   [23:02:35.681] INF TID:2 ######## Test #1: Interop with UniFFI ########
   [23:02:35.691] INF TID:2 #1.1. Call SayHelloAsync in parallel:
   [23:02:35.715] INF TID:8 ##Run 2## [thread=ThreadId(3)][task=Id(2)][sample=296077][pi=3.139291468097826] Hello, Ben!
   [23:02:35.715] INF TID:10 ##Run 1## [thread=ThreadId(3)][task=Id(1)][sample=76775][pi=3.1402409638554216] Hello, Stephen!
   [23:02:35.715] INF TID:11 ##Run 3## [thread=ThreadId(3)][task=Id(3)][sample=25508][pi=3.141602634467618] Hello, John!
   [23:02:35.717] INF TID:11 #1.2. Call SayHelloAsync sequentially:
   [23:02:35.726] INF TID:11 ##Run 1## [thread=ThreadId(3)][task=Id(4)][sample=731946][pi=3.142843870995948] Hello, Stephen!
   [23:02:35.735] INF TID:11 ##Run 2## [thread=ThreadId(3)][task=Id(5)][sample=826046][pi=3.1433939514264337] Hello, Ben!
   [23:02:35.736] INF TID:11 ##Run 3## [thread=ThreadId(3)][task=Id(6)][sample=46098][pi=3.143824027072758] Hello, John!
   ```


## Writing interop manually with mpsc

The Rustonomicon has the following recommendation about writing [async callbacks](https://doc.rust-lang.org/nomicon/ffi.html#asynchronous-callbacks):

> Things get more complicated when the external library spawns its own threads and invokes callbacks from there.
> In these cases access to Rust data structures inside the callbacks is especially unsafe and proper synchronization mechanisms
> must be used. Besides classical synchronization mechanisms like mutexes, one possibility in Rust is to **use channels
> (in `std::sync::mpsc`) to forward data from the C thread that invoked the callback into a Rust thread**.

TODO
