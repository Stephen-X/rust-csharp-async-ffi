# Async C# interop with Rust

This project demos two approaches to create async Rust FFI bindings and C# / .NET scaffoldings.

## Using UniFFI

1. Install [`uniffi-bindgen-cs`](https://github.com/NordSecurity/uniffi-bindgen-cs) with:

   ```bash
   cargo install uniffi-bindgen-cs --git https://github.com/NordSecurity/uniffi-bindgen-cs --tag v0.10.0+v0.29.4
   ```
   Note down the second version number (in the example above, `0.29.4`). This is the upstream [`uniffi`](https://github.com/mozilla/uniffi-rs)
   version used for generating FFI scaffolding in Rust binary that the generated C# bindings will be compatible with. Update `Cargo.toml` accordingly.

2. Build the Rust library with:

   ```bash
   cargo build --release
   ```

   There's no need to write the Rust scaffolding manually, it's auto-generated by UniFFI during build based on info read from [Procedural Macros](https://mozilla.github.io/uniffi-rs/0.29/proc_macro/index.html).

   Compared with popular C# binding generator crates such as [`csbindgen`](https://github.com/Cysharp/csbindgen) that only generate target language bindings based on handwritten Rust FFI scaffolding, `UniFFI` covers both bindings and scaffolding, so it's much easier for quickly setting up interop, especially for handling async code.

   The downsides are:

   1. Interop performance is highly dependent on `UniFFI` implementation (and the corresponding 3rd party binding generator for C#).

   2. There's no control over binding and scaffolding implementations. Whether certain (latest) Rust features can be supported is highly depedent on what `UniFFI` supports (or the version of `UniFFI` that the 3rd party binding generator supports).

   To see the generated [FFI scaffolding code](https://mozilla.github.io/uniffi-rs/0.29/glossary.html#scaffolding), install [`cargo-expand`](https://github.com/dtolnay/cargo-expand) then run `cargo expand --lib`.

3. Generate the C# binding code with:

   ```bash
   uniffi-bindgen-cs.exe --library target\release\async_ffi.dll --out-dir="binding\csharp"
   ```

   Remove the `.exe` extension and change the path to the library to `target/release/libasync_ffi.so` for Linux, or `target/release/libasync_ffi.dylib` for MacOS.

   Alternatively, to generate bindings for Python, use the official `uniffi-bindgen` tool instead, which is in sync with the latest `UniFFI` version:

   ```bash
   cargo run --bin uniffi_bindgen generate --library target\release\async_ffi.dll --language python --out-dir binding\python
   ```

4. Copy `async_ffi.cs` from `binding\csharp` to the root directory of the C# project `dotnet`. Rename the file to `RustInteropUniFFI.cs`.

5. Go to directory `dotnet` and run the C# project with `dotnet run`.

   The `async_ffi.dll` / `libasync_ffi.so` / `libasync_ffi.dylib` library file should be automatically copied to the output directory as part of the build process
   configured in `dotnet.csproj`.

   Example output:

   ```bash
   [00:30:58.631] INF TID:2 ######## Test #1: Interop with UniFFI ########
   [00:30:58.641] INF TID:2 #1.1. Call SayHelloAsync in parallel:
   [00:30:58.667] INF TID:7 ##Run 3## [thread=ThreadId(3)][task=Id(1)][sample=297736][pi=3.1462772388962033] Hello, John!
   [00:30:58.667] INF TID:8 ##Run 1## [thread=ThreadId(3)][task=Id(2)][sample=377845][pi=3.1465283383397953] Hello, Stephen!
   [00:30:58.675] INF TID:8 ##Run 2## [thread=ThreadId(3)][task=Id(3)][sample=724484][pi=3.1402432627911727] Hello, Ben!
   [00:30:58.676] INF TID:8 #Parallel calls completed in 34 ms
   [00:30:58.676] INF TID:8 #1.2. Call SayHelloAsync sequentially:
   [00:30:58.681] INF TID:8 ##Run 1## [thread=ThreadId(3)][task=Id(4)][sample=377845][pi=3.1405999814738847] Hello, Stephen!
   [00:30:58.689] INF TID:8 ##Run 2## [thread=ThreadId(3)][task=Id(5)][sample=724484][pi=3.143186046896826] Hello, Ben!
   [00:30:58.693] INF TID:8 ##Run 3## [thread=ThreadId(3)][task=Id(6)][sample=297736][pi=3.142824515678319] Hello, John!
   [00:30:58.693] INF TID:8 #Sequential calls completed in 16 ms
   ```


## Writing interop manually with Tokio

`src/ffi.rs` and `dotnet/RustInteropTokio.cs` demo how to write async Rust FFI bindings and C# scaffoldings manually with `tokio` runtime.

1. Build the Rust library with:

   ```bash
   cargo build --release
   ```

2. Go to directory `dotnet` and run the C# project with `dotnet run`.

   Example output:

   ```bash
   [00:30:58.693] INF TID:8 ######## Test #2: Interop with async FFI ########
   [00:30:58.693] INF TID:8 #2.1. Call SayHelloAsync in parallel:
   [00:30:58.700] INF TID:10 ##Run 3## [thread=ThreadId(19)][task=Id(27)][sample=297736][pi=3.14052717843996] Hello, John!
   [00:30:58.701] INF TID:11 ##Run 1## [thread=ThreadId(20)][task=Id(26)][sample=377845][pi=3.1402400455213115] Hello, Stephen!
   [00:30:58.704] INF TID:12 ##Run 2## [thread=ThreadId(7)][task=Id(28)][sample=724484][pi=3.1423909982829157] Hello, Ben!
   [00:30:58.705] INF TID:5 #Parallel calls completed in 11 ms
   [00:30:58.705] INF TID:5 #2.2. Call SayHelloAsync sequentially:
   [00:30:58.710] INF TID:12 ##Run 1## [thread=ThreadId(7)][task=Id(30)][sample=377845][pi=3.1428019425955087] Hello, Stephen!
   [00:30:58.719] INF TID:12 ##Run 2## [thread=ThreadId(7)][task=Id(32)][sample=724484][pi=3.1380071885645506] Hello, Ben!
   [00:30:58.722] INF TID:12 ##Run 3## [thread=ThreadId(7)][task=Id(34)][sample=297736][pi=3.1396807910363544] Hello, John!
   [00:30:58.722] INF TID:12 #Sequential calls completed in 17 ms
   ```
